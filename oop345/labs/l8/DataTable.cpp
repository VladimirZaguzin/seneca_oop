
#include "DataTable.h"


using namespace std;


        DataTable(std::ifstream& dataFile, const int FW, const int ND) {

            double tempHighSchool, tempCollege;

            while(dataFile >> tempHighSchool >> tempCollege){
                vecOfHighSchool.push_back(tempHighSchool);
                vecOfCollege.push_back(tempCollege);
            }
        }

        T mean() const {
            return std::accumulate(vecOfCollege.begin(), vecOfCollege.end(), 0.) / vecOfCollege.size();
        } //- returns the mean value of the dependent coordinate
        T sigma() const {
            T average = mean();
            size_t vecSize = vecOfCollege.size();
            T sumOfVec = 0;
/*
            for (int i : vecOfCollege){
                sumOfVec += pow((vecOfCollege[i] - average), 2);
                cout << vecOfCollege[i];
            }
*/
            for(size_t index = 0; index < vecSize; ++index){
                sumOfVec += pow((vecOfCollege[index] - average), 2);
            }


            return sqrt(sumOfVec/(vecSize - 1));

        } // - returns the standard deviation of the dependent coordinates


        T median() const {

            //find out size of vector
            size_t vecSize = vecOfCollege.size();
            //cout << "vecSize: " << vecSize << endl;

            //assign and sort into new vector
            vector<T> bufferVec(vecOfCollege);
            std::sort(bufferVec.begin(), bufferVec.end());


            //in case if we have EVEN number of elements
            if(vecSize % 2 == 0){
                return (bufferVec[(vecSize/2 - 1)] + bufferVec[(vecSize/2)]) / 2;
            }
            else{
                size_t medianElement = (vecSize - 1)/2 + 1;
                //medianElement gives us number starts from 1
                //-1 to access element we really meant
                return bufferVec[medianElement - 1];
            }

        } // - returns the median value of the dependent coordinate

        void regression(T &slope, T &y_intercept) const {
                if(vecOfHighSchool.size() == 0) // Do not divide by zero.
                    throw std::string("Need 1 or more data points to fit a linear regression line.");

                if(vecOfHighSchool.size() != vecOfCollege.size())
                    throw std::string("What? vecOfHighSchool+vecOfCollege sizes are different!");

                double SX = 0.,  SY = 0.,  SXX = 0., SYY = 0.,  SXY = 0.;

                for (int i = 0; i < vecOfHighSchool.size(); i++) {
                    SX  += vecOfHighSchool[i];
                    SY  += vecOfCollege[i];
                    SXX += vecOfHighSchool[i] * vecOfHighSchool[i];
                    SYY += vecOfCollege[i] * vecOfCollege[i];
                    SXY += vecOfHighSchool[i] * vecOfCollege[i];
                }

                size_t n = vecOfCollege.size();

                // or alternatively, using accumulate with a function that happens to be a lambda
                SX =   std::accumulate(vecOfHighSchool.begin(), vecOfHighSchool.end(), double(0.),
                                       [] (double sum, double element) { return sum + element; }
                );

                SY  =  std::accumulate(vecOfCollege.begin(), vecOfCollege.end(), double(0.));

                SXX =  std::accumulate(vecOfHighSchool.begin(), vecOfHighSchool.end(), double(0.),
                                       [] (double sum, double element)
                                       { return sum + element * element; }
                        // calculate sum of vecOfHighSchool squared using function
                );
                SXY =  std::inner_product(vecOfHighSchool.begin(), vecOfHighSchool.end(),
                                          vecOfCollege.begin(), double(0.));

                slope      =  (n*SXY - SX*SY)    / (n*SXX - SX*SX);
                y_intercept  =  (SY - slope * SX) / n;

        } // - returns the slope and intercept for the data set




        void display(std::ostream &os) const {



            os << std::fixed << std::right << std::setw(4) << "X";
            os << "  ";
            os << std::fixed << std::right << std::setw(5) << "Y";
            os << std::endl;
            size_t index = 0;

            for (T elem : vecOfHighSchool){
                os << std::setw(4) << std::fixed << std::setprecision(2) << std::right << elem;
                os << "  ";

                os << std::setw(5) << std::fixed << std::setprecision(2) << vecOfCollege[index++];
                os << std::endl;
            }


        } // - displays the data pairs as shown below
    };

    template<class ST>
    std::ostream &operator<<(std::ostream &os, const DataTable<ST> &data) {
        data.display(os);
        return os;
    } // - inserts the data generated by display() into the output stream

}